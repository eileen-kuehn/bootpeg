# Full PEG+Actions parser
# =======================
spaces:
    | " "*
end_line:
    | spaces [ "#" (!\n) ] ( \n | !. )
identifier:
    | ( ( "a" - "z" ) | ( "A" - "Z" ) | "_" )+
literal:
    | '"' (!'"' .)+ '"' | "'" (!"'" .)+ "'"

# clause producing expressions
atom:
    | "''" | '""' { Empty() }
    | "." { Any(1) }
    | "\n" { Value("\\n") }
    | lower=literal spaces "-" ~ spaces upper=literal { Range(lower, upper) }
    | literal=literal { Value(literal) }
    | name=identifier { Reference(name) }

prefix:
    | "!" spaces expr=prefix { Not(expr) }
    | "(" spaces ~ expr spaces ")"
    | "[" spaces ~ expr=expr spaces "]" { Choice(expr, Empty()) }
    | "*" ~ name=identifier "=" expr=expr { Capture(expr, name, variadic=True) }
    | name=identifier "=" ~ expr=expr { Capture(expr, name, variadic=False) }
    | atom

repeat:
    | expr=prefix spaces "+" { Repeat(expr) }
    | expr=prefix spaces "*" { Choice(Repeat(expr), Empty()) }
    | prefix

sequence:
    | head=repeat *tail=(spaces repeat)+ { Sequence(head, *tail) }
    | *head=(repeat spaces)+ "~" ~ spaces tail=sequence { Sequence(*head, Entail(tail)) }
    | "~" ~ spaces tail=sequence { Entail(tail) }
    | repeat

choice:
    | head=choice space *tail=("|" ~ spaces sequence) { Choice(first, *tail) }
    | sequence

# the top expression, recursively matching all other expressions
expr:
    | choice

# rule and action parsing
action_body:
    | !"{" !"}" .
    | "{" action_body ~ "}"
action:
    | "{" body=action_body ~ "}" { body }

rule_case:
    | expr spaces action { Transform(expr, action) }
    | expr

rule:
    | name=identifier ":" end_line ~cases=(" " spaces "|" spaces rule_case end_line) { Rule(name, cases) }
    | name=identifier ":" ~ expr=rule_case { Rule(name, expr) }
top:
    | *rules=( rule | end_line ) !. { Grammar("top", *rules) }
